[
    {
      "functionality": "Basic CRUD Operations with JDBC - Customer Generated ID",
      "source_code": "String sql = \"INSERT INTO products (id, name, price) VALUES (?, ?, ?)\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setInt(1, 123); // Example of a customer-generated ID\nstmt.setString(2, \"Awesome Product\");\nstmt.setDouble(3, 99.99);\nstmt.executeUpdate();",
      "mysql_schema": "CREATE TABLE products (id INT PRIMARY KEY, name VARCHAR(255), price DECIMAL(10, 2));",
      "spanner_schema": "CREATE TABLE products (\n    id INT64 NOT NULL,\n    name STRING(MAX),\n    price FLOAT64\n) PRIMARY KEY(id),",
      "ground_truth_solution": "String sql = \"INSERT INTO products (id, name, price) VALUES (?, ?, ?)\";\nPreparedStatement stmt = conn.prepareStatement(sql);\n// Assuming the customer-generated ID is provided somehow\nint customerId = 123; //  Get the ID from the customer-side logic\nstmt.setInt(1, customerId);\nstmt.setString(2, \"Awesome Product\");\nstmt.setDouble(3, 99.99);\nstmt.executeUpdate();",
      "description": "No code changes are necessary in this case. Spanner supports customer-generated IDs even though it can auto-generate them."
    },
    {
      "functionality": "Basic CRUD Operations with JDBC - Using UUIDs in Spanner",
      "source_code": "String sql = \"INSERT INTO products (name, price) VALUES (?, ?)\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setString(1, \"Amazing Widget\");\nstmt.setDouble(2, 49.95);\nstmt.executeUpdate();",
      "mysql_schema": "CREATE TABLE products (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255), price DECIMAL(10, 2));",
      "spanner_schema": "CREATE TABLE products (\n    id STRING(36) NOT NULL DEFAULT (GENERATE_UUID()),\n    name STRING(MAX),\n    price FLOAT64\n) PRIMARY KEY(id),",
      "ground_truth_solution": "String sql = \"INSERT INTO products (name, price) VALUES (?, ?)\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setString(1, \"Amazing Widget\");\nstmt.setDouble(2, 49.95); // Correctly omitting the id\nstmt.executeUpdate();",
      "description": "As Spanner doesn't support auto-incrementing IDs, we generate a UUID for the 'id' column during insertion and removed the ID parameter from the prepared statement."
    },
    {
      "functionality": "Using DML Returning in Spanner - Using UUIDs in Spanner",
      "source_code": "String sql = \"INSERT INTO products (name, price) VALUES (?, ?)\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setString(1, \"Amazing Widget\");\nstmt.setDouble(2, 49.95);\nstmt.executeUpdate();\n\n// Retrieve the last inserted ID in MySQL\nString lastIdSql = \"SELECT LAST_INSERT_ID()\";\nStatement lastIdStmt = conn.createStatement();\nResultSet rs = lastIdStmt.executeQuery(lastIdSql);\nif (rs.next()) {\n    int lastInsertedId = rs.getInt(1);\n}",
      "mysql_schema": "CREATE TABLE products (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255), price DECIMAL(10, 2));",
      "spanner_schema": "CREATE TABLE products (\n    id STRING(36) NOT NULL DEFAULT (GENERATE_UUID()),\n    name STRING(MAX),\n    price FLOAT64\n) PRIMARY KEY(id),",
      "ground_truth_solution": "String dmlReturningSql = \"INSERT INTO products (name, price) VALUES (?, ?) RETURNING id\";\nPreparedStatement dmlReturningStmt = conn.prepareStatement(dmlReturningSql);\ndmlReturningStmt.setString(1, \"Amazing Widget\");\ndmlReturningStmt.setDouble(2, 49.95);\nResultSet dmlResultSet = dmlReturningStmt.executeUpdate();\nif (dmlResultSet.next()) {\n    String generatedId = dmlResultSet.getString(1);\n}",
      "description": "The code was modified to use Spanner's DML Returning feature to retrieve the generated UUID. The `id` column is now a STRING(36) and automatically generated by default. We removed the separate query for `LAST_INSERT_ID()` and instead appended `THEN RETURN id` to the INSERT statement. The retrieved ID is then fetched from the ResultSet."
    }, 
    {
      "functionality": "Using DML Returning in Spanner -  Generating a Bit-Reversed Sequence",
      "source_code": "String sql = \"INSERT INTO products (name) VALUES (?)\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setString(1, \"Product 1\");\nstmt.executeUpdate();\n\nString lastIdSql = \"SELECT LAST_INSERT_ID()\";\nStatement lastIdStmt = conn.createStatement();\nResultSet rs = lastIdStmt.executeQuery(lastIdSql);\nif (rs.next()) {\n    int lastInsertedId = rs.getInt(1);\n    // Use lastInsertedId as needed\n}",
      "mysql_schema": "CREATE TABLE products (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255));",
      "spanner_schema": "CREATE SEQUENCE ProductIdSequence OPTIONS (sequence_kind=\"bit_reversed_positive\");\nCREATE TABLE products (\n    id INT64 DEFAULT (GET_NEXT_SEQUENCE_VALUE(SEQUENCE ProductIdSequence)),\n    name STRING(MAX)\n) PRIMARY KEY(id);",
      "ground_truth_solution": "String sql = \"INSERT INTO products (name) VALUES (?) RETURNING id\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setString(1, \"Product 1\");\nResultSet rs = stmt.executeQuery();\nif (rs.next()) {\n    long generatedId = rs.getLong(1);\n    // Use generatedId as needed\n}",
      "description": "Removed the separate query for LAST_INSERT_ID() and used Spanner's DML Returning feature to retrieve the generated ID directly from the INSERT statement. The `THEN RETURN id` clause appends the generated ID to the result set."
    }, 

    {
      "functionality": "Read-only Transaction for Albums",
      "source_code": "static void readOnlyTransaction(\n    final String project,\n    final String instance,\n    final String database,\n    final Properties properties) throws SQLException {\n  try (Connection connection = DriverManager.getConnection(\n      String.format(\n          \"jdbc:cloudspanner:/projects/%s/instances/%s/databases/%s\",\n          project, instance, database),\n      properties)) {\n    // Set AutoCommit=false to enable transactions.\n    connection.setAutoCommit(false);\n    // Set transaction to read-only\n    connection.createStatement().execute(\"SET TRANSACTION READ ONLY\");\n\n    // Perform the first read operation, ordered by SingerId and AlbumId\n    try (ResultSet resultSet = connection.createStatement().executeQuery(\n        \"SELECT SingerId, AlbumId, AlbumTitle \"\n            + \"FROM Albums \"\n            + \"ORDER BY SingerId, AlbumId\")) {\n      System.out.println(\"First Read (by SingerId, AlbumId):\");\n      while (resultSet.next()) {\n        System.out.printf(\n            \"SingerId: %d, AlbumId: %d, AlbumTitle: %s%n\",\n            resultSet.getLong(\"SingerId\"),\n            resultSet.getLong(\"AlbumId\"),\n            resultSet.getString(\"AlbumTitle\"));\n      }\n    }\n\n    // Perform the second read operation, ordered by AlbumTitle\n    try (ResultSet resultSet = connection.createStatement().executeQuery(\n        \"SELECT SingerId, AlbumId, AlbumTitle \"\n            + \"FROM Albums \"\n            + \"ORDER BY AlbumTitle\")) {\n      System.out.println(\"Second Read (by AlbumTitle):\");\n      while (resultSet.next()) {\n        System.out.printf(\n            \"SingerId: %d, AlbumId: %d, AlbumTitle: %s%n\",\n            resultSet.getLong(\"SingerId\"),\n            resultSet.getLong(\"AlbumId\"),\n            resultSet.getString(\"AlbumTitle\"));\n      }\n    }\n    // End the read-only transaction by calling commit().\n    connection.commit();\n  }\n}",
      "mysql_schema": "CREATE TABLE Albums (\n    SingerId INT,\n    AlbumId INT,\n    AlbumTitle VARCHAR(255),\n    PRIMARY KEY (SingerId, AlbumId)\n);",
      "spanner_schema": "CREATE TABLE Albums (\n    SingerId INT64,\n    AlbumId INT64,\n    AlbumTitle STRING(MAX)\n) PRIMARY KEY (SingerId, AlbumId);",
      "ground_truth_solution": "static void readOnlyTransaction(final String project, final String instance, final String database, final Properties properties) throws SQLException {\n  try (Connection connection = DriverManager.getConnection(\n      String.format(\"jdbc:cloudspanner:/projects/%s/instances/%s/databases/%s\", project, instance, database), properties)) {\n    connection.setAutoCommit(false);\n    connection.createStatement().execute(\"SET TRANSACTION READ ONLY\");\n\n    // First query\n    try (ResultSet resultSet = connection.createStatement().executeQuery(\"SELECT SingerId, AlbumId, AlbumTitle FROM Albums ORDER BY SingerId, AlbumId\")) {\n      while (resultSet.next()) {\n        System.out.printf(\"SingerId: %d, AlbumId: %d, AlbumTitle: %s%n\", resultSet.getLong(\"SingerId\"), resultSet.getLong(\"AlbumId\"), resultSet.getString(\"AlbumTitle\"));\n      }\n    }\n\n    // Second query\n    try (ResultSet resultSet = connection.createStatement().executeQuery(\"SELECT SingerId, AlbumId, AlbumTitle FROM Albums ORDER BY AlbumTitle\")) {\n      while (resultSet.next()) {\n        System.out.printf(\"SingerId: %d, AlbumId: %d, AlbumTitle: %s%n\", resultSet.getLong(\"SingerId\"), resultSet.getLong(\"AlbumId\"), resultSet.getString(\"AlbumTitle\"));\n      }\n    }\n    connection.commit();\n  }\n}",
      "description": "This example demonstrates a read-only transaction in Spanner for retrieving album information, adapted from MySQL code."
    },
    {
      "functionality": "Read-only Transaction for Customers and Orders",
      "source_code": "static void readOnlyTransaction(\n    final String project,\n    final String instance,\n    final String database,\n    final Properties properties) throws SQLException {\n  try (Connection connection = DriverManager.getConnection(\n      String.format(\n          \"jdbc:cloudspanner:/projects/%s/instances/%s/databases/%s\",\n          project, instance, database),\n      properties)) {\n    // Set AutoCommit=false to enable transactions.\n    connection.setAutoCommit(false);\n    connection.createStatement().execute(\"SET TRANSACTION READ ONLY\");\n\n    // First query: Retrieve customers and their orders\n    try (ResultSet resultSet = connection.createStatement().executeQuery(\n        \"SELECT c.CustomerId, c.CustomerName, o.OrderId, o.OrderDate \"\n            + \"FROM Customers c \"\n            + \"LEFT JOIN Orders o ON c.CustomerId = o.CustomerId \"\n            + \"ORDER BY c.CustomerId, o.OrderDate DESC\")) {\n      System.out.println(\"Customers and their Orders:\");\n      while (resultSet.next()) {\n        System.out.printf(\n            \"CustomerId: %d, CustomerName: %s, OrderId: %d, OrderDate: %s%n\",\n            resultSet.getLong(\"CustomerId\"),\n            resultSet.getString(\"CustomerName\"),\n            resultSet.getLong(\"OrderId\"),\n            resultSet.getDate(\"OrderDate\"));\n      }\n    }\n\n    // Second query: Retrieve order items for a specific order\n    try (ResultSet resultSet = connection.createStatement().executeQuery(\n        \"SELECT oi.OrderId, oi.ItemId, oi.Quantity, p.ProductName \"\n            + \"FROM OrderItems oi \"\n            + \"JOIN Products p ON oi.ItemId = p.ProductId \"\n            + \"WHERE oi.OrderId = (SELECT MAX(OrderId) FROM Orders) \"\n            + \"ORDER BY oi.ItemId\")) {\n      System.out.println(\"Order Items for the Most Recent Order:\");\n      while (resultSet.next()) {\n        System.out.printf(\n            \"OrderId: %d, ItemId: %d, Quantity: %d, ProductName: %s%n\",\n            resultSet.getLong(\"OrderId\"),\n            resultSet.getLong(\"ItemId\"),\n            resultSet.getInt(\"Quantity\"),\n            resultSet.getString(\"ProductName\"));\n      }\n    }\n    // End the read-only transaction by calling commit().\n    connection.commit();\n  }\n}",
      "mysql_schema": "CREATE TABLE Customers (\n    CustomerId INT PRIMARY KEY,\n    CustomerName VARCHAR(255)\n);\n\nCREATE TABLE Orders (\n    OrderId INT PRIMARY KEY,\n    CustomerId INT,\n    OrderDate DATE,\n    FOREIGN KEY (CustomerId) REFERENCES Customers(CustomerId)\n);\n\nCREATE TABLE Products (\n    ProductId INT PRIMARY KEY,\n    ProductName VARCHAR(255)\n);\n\nCREATE TABLE OrderItems (\n    OrderId INT,\n    ItemId INT,\n    Quantity INT,\n    PRIMARY KEY (OrderId, ItemId),\n    FOREIGN KEY (OrderId) REFERENCES Orders(OrderId),\n    FOREIGN KEY (ItemId) REFERENCES Products(ProductId)\n);",
      "spanner_schema": "CREATE TABLE Customers (\n    CustomerId INT64 NOT NULL,\n    CustomerName STRING(MAX),\n) PRIMARY KEY (CustomerId);\n\nCREATE TABLE Orders (\n    OrderId INT64 NOT NULL,\n    CustomerId INT64,\n    OrderDate DATE,\n) PRIMARY KEY (OrderId);\n\nCREATE TABLE Products (\n    ProductId INT64 NOT NULL,\n    ProductName STRING(MAX),\n) PRIMARY KEY (ProductId);\n\nCREATE TABLE OrderItems (\n    OrderId INT64 NOT NULL,\n    ItemId INT64 NOT NULL,\n    Quantity INT64,\n) PRIMARY KEY (OrderId, ItemId);",
      "ground_truth_solution": "static void readOnlyTransaction(final String project, final String instance, final String database, final Properties properties) throws SQLException {\n  try (Connection connection = DriverManager.getConnection(\n      String.format(\"jdbc:cloudspanner:/projects/%s/instances/%s/databases/%s\", project, instance, database), properties)) {\n    connection.setAutoCommit(false);\n    connection.createStatement().execute(\"SET TRANSACTION READ ONLY\");\n\n    // First query: Retrieve customers and their orders\n    try (ResultSet resultSet = connection.createStatement().executeQuery(\"SELECT c.CustomerId, c.CustomerName, o.OrderId, o.OrderDate FROM Customers c LEFT JOIN Orders o ON c.CustomerId = o.CustomerId ORDER BY c.CustomerId, o.OrderDate DESC\")) {\n      while (resultSet.next()) {\n        System.out.printf(\"CustomerId: %d, CustomerName: %s, OrderId: %d, OrderDate: %s%n\", resultSet.getLong(\"CustomerId\"), resultSet.getString(\"CustomerName\"), resultSet.getLong(\"OrderId\"), resultSet.getDate(\"OrderDate\"));\n      }\n    }\n\n    // Second query: Retrieve order items for the most recent order\n    try (ResultSet resultSet = connection.createStatement().executeQuery(\"SELECT oi.OrderId, oi.ItemId, oi.Quantity, p.ProductName FROM OrderItems oi JOIN Products p ON oi.ItemId = p.ProductId WHERE oi.OrderId = (SELECT MAX(OrderId) FROM Orders) ORDER BY oi.ItemId\")) {\n      while (resultSet.next()) {\n        System.out.printf(\"OrderId: %d, ItemId: %d, Quantity: %d, ProductName: %s%n\", resultSet.getLong(\"OrderId\"), resultSet.getLong(\"ItemId\"), resultSet.getInt(\"Quantity\"), resultSet.getString(\"ProductName\"));\n      }\n    }\n    connection.commit();\n  }\n}",
      "description": "This example demonstrates a read-only transaction in Spanner for retrieving customer and order information, including order items, with complex relationships between multiple tables."
    },

    {
      "functionality": "Bulk Read Data from Albums",
      "source_code": "static void readBulkData(\n    final String project,\n    final String instance,\n    final String database,\n    final Properties properties) throws SQLException {\n  try (Connection connection = DriverManager.getConnection(\n      String.format(\n          \"jdbc:cloudspanner:/projects/%s/instances/%s/databases/%s\",\n          project, instance, database),\n      properties)) {\n    // Run a query to fetch bulk data\n    String query = \"SELECT SingerId, AlbumId, AlbumTitle FROM Albums\";\n    try (PreparedStatement pstmt = connection.prepareStatement(query)) {\n      pstmt.setFetchSize(100); // Set fetch size for bulk read\n      try (ResultSet resultSet = pstmt.executeQuery()) {\n        while (resultSet.next()) {\n          // Process record\n          long singerId = resultSet.getLong(\"SingerId\");\n          long albumId = resultSet.getLong(\"AlbumId\");\n          String albumTitle = resultSet.getString(\"AlbumTitle\");\n          System.out.printf(\"SingerId: %d, AlbumId: %d, AlbumTitle: %s%n\",\n              singerId, albumId, albumTitle);\n        }\n      }\n    }\n  } catch (SQLException e) {\n    e.printStackTrace();\n    throw e; // Rethrow to propagate the exception\n  }\n}",
      "mysql_schema": "CREATE TABLE Albums (\n    SingerId INT,\n    AlbumId INT,\n    AlbumTitle VARCHAR(255),\n    PRIMARY KEY (SingerId, AlbumId)\n);",
      "spanner_schema": "CREATE TABLE Albums (\n    SingerId INT64,\n    AlbumId INT64,\n    AlbumTitle STRING(MAX)\n) PRIMARY KEY (SingerId, AlbumId);",
      "ground_truth_solution": "static void readBulkData(final String project, final String instance, final String database, final Properties properties) throws SQLException {\n  try (Connection connection = DriverManager.getConnection(\n      String.format(\"jdbc:cloudspanner:/projects/%s/instances/%s/databases/%s\", project, instance, database), properties)) {\n    String query = \"SELECT SingerId, AlbumId, AlbumTitle FROM Albums\";\n    try (PreparedStatement pstmt = connection.prepareStatement(query)) {\n      pstmt.setFetchSize(100); // Set fetch size for bulk read\n      try (ResultSet resultSet = pstmt.executeQuery()) {\n        while (resultSet.next()) {\n          long singerId = resultSet.getLong(\"SingerId\");\n          long albumId = resultSet.getLong(\"AlbumId\");\n          String albumTitle = resultSet.getString(\"AlbumTitle\");\n          System.out.printf(\"SingerId: %d, AlbumId: %d, AlbumTitle: %s%n\", singerId, albumId, albumTitle);\n        }\n      }\n    }\n  } catch (SQLException e) {\n    e.printStackTrace();\n    throw e;\n  }\n}",
      "description": "This example demonstrates bulk reading of album data using prepared statements in Spanner, similar to MySQL. The main changes include removing Spanner-specific features like Data Boost and maintaining consistent logic for data fetching and processing. Both implementations set a fetch size to optimize reading bulk data."
    },
    {
      "functionality": "Date/Time Data Type Conversion with JDBC",
      "source_code": "String sql = \"INSERT INTO events (name, event_date) VALUES (?, ?)\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setString(1, \"Workshop\");\nstmt.setDate(2, new java.sql.Date(System.currentTimeMillis()));\nstmt.executeUpdate();",
      "mysql_schema": "CREATE TABLE events (id INT PRIMARY KEY, name VARCHAR(255), event_date DATE);",
      "spanner_schema": "CREATE TABLE events (\n  id INT64 NOT NULL,\n  name STRING(MAX),\n  event_date DATE\n) PRIMARY KEY(id),",
      "ground_truth_solution": "String sql = \"INSERT INTO events (id, name, event_date) VALUES (?, ?, ?)\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setLong(1, idGenerator.generateId()); // Or any other ID generation method\nstmt.setString(2, \"Workshop\");\nstmt.setDate(2, com.google.cloud.Date.fromJavaUtilDate(new java.util.Date())); // Use Spanner Date\nstmt.executeUpdate();",
      "description": "While both MySQL and Spanner support the DATE data type, use the Spanner JDBC driver's specific date handling for consistency. This involves converting a Java `java.util.Date` to a `com.google.cloud.Date` object before setting it in the PreparedStatement. Since Spanner doesn't have AUTO_INCREMENT, you'll need a separate ID generation strategy."
    },
    {
      "functionality": "ResultSet Metadata with JDBC",
      "source_code": "Statement stmt = conn.createStatement();\nResultSet rs = stmt.executeQuery(\"SELECT * FROM employees\");\nResultSetMetaData metaData = rs.getMetaData();\nint columnCount = metaData.getColumnCount();\nfor (int i = 1; i <= columnCount; i++) {\n  String columnName = metaData.getColumnName(i);\n  String columnType = metaData.getColumnTypeName(i);\n  // ... process column metadata\n}",
      "mysql_schema": "CREATE TABLE employees (id INT PRIMARY KEY, name VARCHAR(255), salary DECIMAL, hire_date DATE);",
      "spanner_schema": "CREATE TABLE employees (\n  id INT64 NOT NULL,\n  name STRING(MAX),\n  salary NUMERIC,\n  hire_date DATE\n) PRIMARY KEY(id);",
      "ground_truth_solution": "Statement stmt = conn.createStatement();\nResultSet rs = stmt.executeQuery(\"SELECT * FROM employees\");\nResultSetMetaData metaData = rs.getMetaData();\nint columnCount = metaData.getColumnCount();\nfor (int i = 1; i <= columnCount; i++) {\n  String columnName = metaData.getColumnName(i);\n  String columnType = metaData.getColumnTypeName(i);\n  // ... (no changes needed for metadata processing with JDBC)\n}",
      "description": "When using `ResultSetMetaData` with the Spanner JDBC driver, no specific adjustments are typically needed for metadata processing, as the driver handles the mapping of data types and column names."
    },
    {
      "functionality": "Batch Updates with JDBC",
      "source_code": "String sql = \"UPDATE accounts SET balance = balance + ? WHERE id = ?\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nconn.setAutoCommit(false); // Start a transaction\nfor (Account account : accountsToUpdate) {\n  stmt.setBigDecimal(1, account.getAmount());\n  stmt.setInt(2, account.getId());\n  stmt.addBatch();\n}\nstmt.executeBatch();\nconn.commit();",
      "mysql_schema": "CREATE TABLE accounts (id INT PRIMARY KEY, balance DECIMAL);",
      "spanner_schema": "CREATE TABLE accounts (\n  id INT64 NOT NULL,\n  balance NUMERIC\n) PRIMARY KEY(id);",
      "ground_truth_solution": "String sql = \"UPDATE accounts SET balance = balance + ? WHERE id = ?\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nconn.setAutoCommit(false); // Start a transaction\nfor (Account account : accountsToUpdate) {\n  stmt.setBigDecimal(1, account.getAmount());\n  stmt.setLong(2, account.getId());\n  stmt.addBatch();\n}\nstmt.executeBatch();\nconn.commit();",
      "description": "Used Partitioned DML for efficient batch updates in Spanner. Replaced conn.setAutoCommit(false) and conn.commit() with Spanner's implicit transaction management for Partitioned DML. Changed stmt.setInt to stmt.setLong to match the Spanner schema (INT64)."
    },
    {
      "functionality": "Transactions with JDBC",
      "source_code": "conn.setAutoCommit(false);\ntry {\n  // ... perform multiple DML statements\n  conn.commit();\n} catch (SQLException e) {\n  conn.rollback();\n}",
      "mysql_schema": "...",
      "spanner_schema": "...",
      "ground_truth_solution": "conn.setAutoCommit(false);\ntry {\n  // ... perform multiple DML statements (using PreparedStatement)\n  conn.commit();\n} catch (SQLException e) {\n  conn.rollback();\n}",
      "description": "The Spanner JDBC driver supports transactions similar to MySQL. The tool should correctly identify the transaction boundaries and use the standard JDBC methods (`setAutoCommit`, `commit`, `rollback`) for transaction management."
    },
    {
      "functionality": "JDBC Configuration Migration",
      "mysql_schema": "...",
      "spanner_schema": "...",
      "source_code": "static void configureJdbcConnection(final String instance, final String database) throws SQLException {\n  // MySQL JDBC Connection\n  String mysqlUrl = String.format(\"jdbc:mysql://%s/%s\", instance, database);\n  Properties mysqlProperties = new Properties();\n  mysqlProperties.setProperty(\"user\", \"username\");\n  mysqlProperties.setProperty(\"password\", \"password\");\n  mysqlProperties.setProperty(\"useSSL\", \"false\"); // MySQL SSL config\n\n  try (Connection mysqlConnection = DriverManager.getConnection(mysqlUrl, mysqlProperties)) {\n    System.out.println(\"MySQL connection successful.\");\n  }\n}",
      "ground_truth_solution": "static void configureJdbcConnection(final String project, final String instance, final String database) throws SQLException {\n  // Spanner JDBC Connection\n  String spannerUrl = String.format(\"jdbc:cloudspanner:/projects/%s/instances/%s/databases/%s\", project, instance, database);\n\n  try (Connection spannerConnection = DriverManager.getConnection(spannerUrl)) {\n    System.out.println(\"Spanner connection successful.\");\n  }\n}",
      "description": "Migrated connection logic to use Spanner JDBC driver and connection string. Replaced MySQL specific properties with Spanner authentication options. Assuming PROJECT is provided separately or via environment."
    },
    {
      "functionality": "Maven Dependency Update",
      "mysql_schema": "...",
      "spanner_schema": "...",
      "source_code": "<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>8.0.28</version>\n</dependency>",
      "ground_truth_solution": "<dependency>\n    <groupId>com.google.cloud</groupId>\n    <artifactId>google-cloud-spanner-jdbc</artifactId>\n    <version>2.18.0</version>\n</dependency>",
      "description": "Replaced MySQL JDBC dependency with Cloud Spanner JDBC dependency."
    },

    {
      "functionality": "Basic SELECT Query - Retrieving Product Details",
      "source_code": "String sql = \"SELECT name, price FROM products WHERE id = ?\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setInt(1, 123);\nResultSet rs = stmt.executeQuery();\nif (rs.next()) {\n    String productName = rs.getString(\"name\");\n    double productPrice = rs.getDouble(\"price\");\n}",
      "mysql_schema": "CREATE TABLE products (id INT PRIMARY KEY, name VARCHAR(255), price DECIMAL(10, 2));",
      "spanner_schema": "CREATE TABLE products (\n    id INT64 NOT NULL,\n    name STRING(MAX),\n    price FLOAT64\n) PRIMARY KEY(id);",
      "ground_truth_solution": "String sql = \"SELECT name, price FROM products WHERE id = ?\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setLong(1, 123L);\nResultSet rs = stmt.executeQuery();\nif (rs.next()) {\n    String productName = rs.getString(\"name\");\n    double productPrice = rs.getDouble(\"price\");\n}",
      "description": "No significant code changes except that in Spanner, INT is mapped to INT64, so we use `setLong()` instead of `setInt()`."
    },
    {
      "functionality": "Join Query - Fetch Orders with Product Names",
      "source_code": "String sql = \"SELECT o.id, p.name, o.quantity FROM orders o JOIN products p ON o.product_id = p.id WHERE o.customer_id = ?\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setInt(1, 456);\nResultSet rs = stmt.executeQuery();\nwhile (rs.next()) {\n    int orderId = rs.getInt(\"id\");\n    String productName = rs.getString(\"name\");\n    int quantity = rs.getInt(\"quantity\");\n}",
      "mysql_schema": "CREATE TABLE orders (id INT PRIMARY KEY, product_id INT, customer_id INT, quantity INT);\nCREATE TABLE products (id INT PRIMARY KEY, name VARCHAR(255), price DECIMAL(10, 2));",
      "spanner_schema": "CREATE TABLE orders (\n    id INT64 NOT NULL,\n    product_id INT64 NOT NULL,\n    customer_id INT64 NOT NULL,\n    quantity INT64\n) PRIMARY KEY(id);\nCREATE TABLE products (\n    id INT64 NOT NULL,\n    name STRING(MAX),\n    price FLOAT64\n) PRIMARY KEY(id);",
      "ground_truth_solution": "String sql = \"SELECT o.id, p.name, o.quantity FROM orders o JOIN products p ON o.product_id = p.id WHERE o.customer_id = ?\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setLong(1, 456L);\nResultSet rs = stmt.executeQuery();\nwhile (rs.next()) {\n    long orderId = rs.getLong(\"id\");\n    String productName = rs.getString(\"name\");\n    long quantity = rs.getLong(\"quantity\");\n}",
      "description": "Adapted the schema to Spanner's INT64 for all integer columns and updated the code accordingly to use `setLong()` instead of `setInt()`."
    },
    {
      "functionality": "Aggregation Query - Total Sales Per Product",
      "source_code": "String sql = \"SELECT p.name, SUM(o.quantity * p.price) as total_sales FROM orders o JOIN products p ON o.product_id = p.id GROUP BY p.name\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();\nwhile (rs.next()) {\n    String productName = rs.getString(\"name\");\n    double totalSales = rs.getDouble(\"total_sales\");\n}",
      "mysql_schema": "CREATE TABLE orders (id INT PRIMARY KEY, product_id INT, quantity INT);\nCREATE TABLE products (id INT PRIMARY KEY, name VARCHAR(255), price DECIMAL(10, 2));",
      "spanner_schema": "CREATE TABLE orders (\n    id INT64 NOT NULL,\n    product_id INT64 NOT NULL,\n    quantity INT64\n) PRIMARY KEY(id);\nCREATE TABLE products (\n    id INT64 NOT NULL,\n    name STRING(MAX),\n    price FLOAT64\n) PRIMARY KEY(id);",
      "ground_truth_solution": "String sql = \"SELECT p.name, SUM(o.quantity * p.price) as total_sales FROM orders o JOIN products p ON o.product_id = p.id GROUP BY p.name\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();\nwhile (rs.next()) {\n    String productName = rs.getString(\"name\");\n    double totalSales = rs.getDouble(\"total_sales\");\n}",
      "description": "No code changes are required for aggregation queries; Spanner supports all standard SQL aggregation functions like SUM, AVG, etc."
    },
    {
      "functionality": "Using ADDDATE in a Query - Adding Days to a Date",
      "source_code": "String sql = \"SELECT id, name, ADDDATE(order_date, INTERVAL 10 DAY) AS delivery_date FROM orders\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();",
      "mysql_schema": "CREATE TABLE orders (id INT PRIMARY KEY, name VARCHAR(255), order_date DATE);",
      "spanner_schema": "CREATE TABLE orders (\n    id INT64 NOT NULL,\n    name STRING(MAX),\n    order_date DATE\n) PRIMARY KEY(id);",
      "ground_truth_solution": "String sql = \"SELECT id, name, DATE_ADD(order_date, INTERVAL 10 DAY) AS delivery_date FROM orders\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();",
      "description": "In Spanner, `ADDDATE` is replaced by `DATE_ADD`. The signature remains the same, using the interval keyword."
    },
    {
      "functionality": "Using GROUP_CONCAT in a Query - Concatenating Strings",
      "source_code": "String sql = \"SELECT GROUP_CONCAT(name) AS all_names FROM users WHERE role = 'admin'\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();",
      "mysql_schema": "CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(255), role VARCHAR(50));",
      "spanner_schema": "CREATE TABLE users (\n    id INT64 NOT NULL,\n    name STRING(MAX),\n    role STRING(MAX)\n) PRIMARY KEY(id);",
      "ground_truth_solution": "String sql = \"SELECT STRING_AGG(name) AS all_names FROM users WHERE role = 'admin'\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();",
      "description": "In Spanner, `GROUP_CONCAT` is replaced by `STRING_AGG` for aggregating strings. The syntax for the function call is similar but uses the new function name."
    },
    {
      "functionality": "Using INSTR in a Query - Finding Substring Position",
      "source_code": "String sql = \"SELECT name, INSTR(name, 'abc') AS position FROM users\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();",
      "mysql_schema": "CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(255));",
      "spanner_schema": "CREATE TABLE users (\n    id INT64 NOT NULL,\n    name STRING(MAX)\n) PRIMARY KEY(id);",
      "ground_truth_solution": "String sql = \"SELECT name, STRPOS(name, 'abc') AS position FROM users\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();",
      "description": "In Spanner, `INSTR` is replaced by `STRPOS`, which also returns the position of the substring within a string."
    },
    {
      "functionality": "Using LCASE in a Query - Converting to Lowercase",
      "source_code": "String sql = \"SELECT id, LCASE(name) AS lower_name FROM users\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();",
      "mysql_schema": "CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(255));",
      "spanner_schema": "CREATE TABLE users (\n    id INT64 NOT NULL,\n    name STRING(MAX)\n) PRIMARY KEY(id);",
      "ground_truth_solution": "String sql = \"SELECT id, LOWER(name) AS lower_name FROM users\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();",
      "description": "In Spanner, `LCASE` is replaced by `LOWER` to convert string values to lowercase."
    },
    {
      "functionality": "Using LOCALTIME in a Query - Retrieving Current Time",
      "source_code": "String sql = \"SELECT id, name, LOCALTIME() AS current_time FROM users\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();",
      "mysql_schema": "CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(255));",
      "spanner_schema": "CREATE TABLE users (\n    id INT64 NOT NULL,\n    name STRING(MAX)\n) PRIMARY KEY(id);",
      "ground_truth_solution": "String sql = \"SELECT id, name, CURRENT_TIMESTAMP() AS current_time FROM users\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();",
      "description": "In Spanner, `LOCALTIME()` is replaced by `CURRENT_TIMESTAMP()` to retrieve the current time."
    },
    {
      "functionality": "Using SUBSTRING in a Query - Extracting Part of a String",
      "source_code": "String sql = \"SELECT SUBSTRING(name, 1, 3) AS short_name FROM users\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();",
      "mysql_schema": "CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(255));",
      "spanner_schema": "CREATE TABLE users (\n    id INT64 NOT NULL,\n    name STRING(MAX)\n) PRIMARY KEY(id);",
      "ground_truth_solution": "String sql = \"SELECT SUBSTR(name, 1, 3) AS short_name FROM users\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();",
      "description": "In Spanner, `SUBSTRING` is replaced by `SUBSTR`, and the signature remains the same for extracting part of a string."
    },
    {
      "functionality": "Using UCASE in a Query - Converting to Uppercase",
      "source_code": "String sql = \"SELECT UCASE(name) AS upper_name FROM users\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();",
      "mysql_schema": "CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(255));",
      "spanner_schema": "CREATE TABLE users (\n    id INT64 NOT NULL,\n    name STRING(MAX)\n) PRIMARY KEY(id);",
      "ground_truth_solution": "String sql = \"SELECT UPPER(name) AS upper_name FROM users\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();",
      "description": "In Spanner, `UCASE` is replaced by `UPPER` to convert string values to uppercase."
    },
    {
      "functionality": "Using SUBDATE in a Query - Subtracting Days from a Date",
      "source_code": "String sql = \"SELECT id, SUBDATE(order_date, INTERVAL 5 DAY) AS shipment_date FROM orders\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();",
      "mysql_schema": "CREATE TABLE orders (id INT PRIMARY KEY, order_date DATE);",
      "spanner_schema": "CREATE TABLE orders (\n    id INT64 NOT NULL,\n    order_date DATE\n) PRIMARY KEY(id);",
      "ground_truth_solution": "String sql = \"SELECT id, DATE_SUB(order_date, INTERVAL 5 DAY) AS shipment_date FROM orders\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nResultSet rs = stmt.executeQuery();",
      "description": "In Spanner, `SUBDATE` is replaced by `DATE_SUB` for subtracting days from a date."
    } 
  
  ]