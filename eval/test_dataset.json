[
    {
      "functionality": "Basic CRUD Operations with JDBC - Customer Generated ID",
      "source_code": "String sql = \"INSERT INTO products (id, name, price) VALUES (?, ?, ?)\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setInt(1, 123); // Example of a customer-generated ID\nstmt.setString(2, \"Awesome Product\");\nstmt.setDouble(3, 99.99);\nstmt.executeUpdate();",
      "mysql_schema": "CREATE TABLE products (id INT PRIMARY KEY, name VARCHAR(255), price DECIMAL(10, 2));",
      "spanner_schema": "CREATE TABLE products (\n    id INT64 NOT NULL,\n    name STRING(MAX),\n    price FLOAT64\n) PRIMARY KEY(id),",
      "ground_truth_solution": "String sql = \"INSERT INTO products (id, name, price) VALUES (?, ?, ?)\";\nPreparedStatement stmt = conn.prepareStatement(sql);\n// Assuming the customer-generated ID is provided somehow\nint customerId = 123; //  Get the ID from the customer-side logic\nstmt.setInt(1, customerId);\nstmt.setString(2, \"Awesome Product\");\nstmt.setDouble(3, 99.99);\nstmt.executeUpdate();",
      "description": "In this scenario, the customer generates the `id` on their side. The Spanner schema remains the same, with `id` as the primary key. The application code needs to ensure the uniqueness of customer-generated IDs to avoid conflicts."
    },
    {
      "functionality": "Basic CRUD Operations with JDBC - Using UUIDs in Spanner",
      "source_code": "String sql = \"INSERT INTO products (name, price) VALUES (?, ?)\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setString(1, \"Amazing Widget\");\nstmt.setDouble(2, 49.95);\nstmt.executeUpdate();",
      "mysql_schema": "CREATE TABLE products (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255), price DECIMAL(10, 2));",
      "spanner_schema": "CREATE TABLE products (\n    id STRING(36) NOT NULL DEFAULT (GENERATE_UUID()),\n    name STRING(MAX),\n    price FLOAT64\n) PRIMARY KEY(id),",
      "ground_truth_solution": "String sql = \"INSERT INTO products (name, price) VALUES (?, ?)\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setString(1, \"Amazing Widget\");\nstmt.setDouble(2, 49.95); // Correctly omitting the id\nstmt.executeUpdate();",
      "description": "Spanner automatically generates UUIDs for the `id` column. No need for customer-side ID generation or retrieving generated keys."
    },
    {
      "functionality": "Using DML Returning in Spanner - Using UUIDs in Spanner",
      "source_code": "String sql = \"INSERT INTO products (name, price) VALUES (?, ?)\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setString(1, \"Amazing Widget\");\nstmt.setDouble(2, 49.95);\nstmt.executeUpdate();\n\n// Retrieve the last inserted ID in MySQL\nString lastIdSql = \"SELECT LAST_INSERT_ID()\";\nStatement lastIdStmt = conn.createStatement();\nResultSet rs = lastIdStmt.executeQuery(lastIdSql);\nif (rs.next()) {\n    int lastInsertedId = rs.getInt(1);\n}",
      "mysql_schema": "CREATE TABLE products (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255), price DECIMAL(10, 2));",
      "spanner_schema": "CREATE TABLE products (\n    id STRING(36) NOT NULL DEFAULT (GENERATE_UUID()),\n    name STRING(MAX),\n    price FLOAT64\n) PRIMARY KEY(id),",
      "ground_truth_solution": "String dmlReturningSql = \"INSERT INTO products (name, price) VALUES (?, ?) RETURNING id\";\nPreparedStatement dmlReturningStmt = conn.prepareStatement(dmlReturningSql);\ndmlReturningStmt.setString(1, \"Amazing Widget\");\ndmlReturningStmt.setDouble(2, 49.95);\nResultSet dmlResultSet = dmlReturningStmt.executeUpdate();\nif (dmlResultSet.next()) {\n    String generatedId = dmlResultSet.getString(1);\n}",
      "description": "In MySQL, you retrieve the last inserted ID using LAST_INSERT_ID(). In Spanner, you can use DML returning to get the generated UUID directly after the insert."
    }, 
    {
      "functionality": "Using DML Returning in Spanner -  Generating a Bit-Reversed Sequence",
      "source_code": "String sql = \"INSERT INTO products (name) VALUES (?)\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setString(1, \"Product 1\");\nstmt.executeUpdate();\n\nString lastIdSql = \"SELECT LAST_INSERT_ID()\";\nStatement lastIdStmt = conn.createStatement();\nResultSet rs = lastIdStmt.executeQuery(lastIdSql);\nif (rs.next()) {\n    int lastInsertedId = rs.getInt(1);\n    // Use lastInsertedId as needed\n}",
      "mysql_schema": "CREATE TABLE products (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255));",
      "spanner_schema": "CREATE SEQUENCE ProductIdSequence OPTIONS (sequence_kind=\"bit_reversed_positive\");\nCREATE TABLE products (\n    id INT64 DEFAULT (GET_NEXT_SEQUENCE_VALUE(SEQUENCE ProductIdSequence)),\n    name STRING(MAX)\n) PRIMARY KEY(id);",
      "ground_truth_solution": "String sql = \"INSERT INTO products (name) VALUES (?) RETURNING id\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setString(1, \"Product 1\");\nResultSet rs = stmt.executeQuery();\nif (rs.next()) {\n    long generatedId = rs.getLong(1);\n    // Use generatedId as needed\n}",
      "description": "In MySQL, you retrieve the last inserted ID using LAST_INSERT_ID(). In Spanner, you can use a bit-reversed sequence to generate IDs directly during inserts."
    }, 

    {
      "functionality": "Read-only Transaction for Albums",
      "source_code": "static void readOnlyTransaction(\n    final String project,\n    final String instance,\n    final String database,\n    final Properties properties) throws SQLException {\n  try (Connection connection = DriverManager.getConnection(\n      String.format(\n          \"jdbc:cloudspanner:/projects/%s/instances/%s/databases/%s\",\n          project, instance, database),\n      properties)) {\n    // Set AutoCommit=false to enable transactions.\n    connection.setAutoCommit(false);\n    // Set transaction to read-only\n    connection.createStatement().execute(\"SET TRANSACTION READ ONLY\");\n\n    // Perform the first read operation, ordered by SingerId and AlbumId\n    try (ResultSet resultSet = connection.createStatement().executeQuery(\n        \"SELECT SingerId, AlbumId, AlbumTitle \"\n            + \"FROM Albums \"\n            + \"ORDER BY SingerId, AlbumId\")) {\n      System.out.println(\"First Read (by SingerId, AlbumId):\");\n      while (resultSet.next()) {\n        System.out.printf(\n            \"SingerId: %d, AlbumId: %d, AlbumTitle: %s%n\",\n            resultSet.getLong(\"SingerId\"),\n            resultSet.getLong(\"AlbumId\"),\n            resultSet.getString(\"AlbumTitle\"));\n      }\n    }\n\n    // Perform the second read operation, ordered by AlbumTitle\n    try (ResultSet resultSet = connection.createStatement().executeQuery(\n        \"SELECT SingerId, AlbumId, AlbumTitle \"\n            + \"FROM Albums \"\n            + \"ORDER BY AlbumTitle\")) {\n      System.out.println(\"Second Read (by AlbumTitle):\");\n      while (resultSet.next()) {\n        System.out.printf(\n            \"SingerId: %d, AlbumId: %d, AlbumTitle: %s%n\",\n            resultSet.getLong(\"SingerId\"),\n            resultSet.getLong(\"AlbumId\"),\n            resultSet.getString(\"AlbumTitle\"));\n      }\n    }\n    // End the read-only transaction by calling commit().\n    connection.commit();\n  }\n}",
      "mysql_schema": "CREATE TABLE Albums (\n    SingerId INT,\n    AlbumId INT,\n    AlbumTitle VARCHAR(255),\n    PRIMARY KEY (SingerId, AlbumId)\n);",
      "spanner_schema": "CREATE TABLE Albums (\n    SingerId INT64,\n    AlbumId INT64,\n    AlbumTitle STRING(MAX)\n) PRIMARY KEY (SingerId, AlbumId);",
      "ground_truth_solution": "static void readOnlyTransaction(final String project, final String instance, final String database, final Properties properties) throws SQLException {\n  try (Connection connection = DriverManager.getConnection(\n      String.format(\"jdbc:cloudspanner:/projects/%s/instances/%s/databases/%s\", project, instance, database), properties)) {\n    connection.setAutoCommit(false);\n    connection.createStatement().execute(\"SET TRANSACTION READ ONLY\");\n\n    // First query\n    try (ResultSet resultSet = connection.createStatement().executeQuery(\"SELECT SingerId, AlbumId, AlbumTitle FROM Albums ORDER BY SingerId, AlbumId\")) {\n      while (resultSet.next()) {\n        System.out.printf(\"SingerId: %d, AlbumId: %d, AlbumTitle: %s%n\", resultSet.getLong(\"SingerId\"), resultSet.getLong(\"AlbumId\"), resultSet.getString(\"AlbumTitle\"));\n      }\n    }\n\n    // Second query\n    try (ResultSet resultSet = connection.createStatement().executeQuery(\"SELECT SingerId, AlbumId, AlbumTitle FROM Albums ORDER BY AlbumTitle\")) {\n      while (resultSet.next()) {\n        System.out.printf(\"SingerId: %d, AlbumId: %d, AlbumTitle: %s%n\", resultSet.getLong(\"SingerId\"), resultSet.getLong(\"AlbumId\"), resultSet.getString(\"AlbumTitle\"));\n      }\n    }\n    connection.commit();\n  }\n}",
      "description": "This example demonstrates a read-only transaction in Spanner for retrieving album information, adapted from MySQL code."
    },
    {
      "functionality": "Read-only Transaction for Customers and Orders",
      "source_code": "static void readOnlyTransaction(\n    final String project,\n    final String instance,\n    final String database,\n    final Properties properties) throws SQLException {\n  try (Connection connection = DriverManager.getConnection(\n      String.format(\n          \"jdbc:cloudspanner:/projects/%s/instances/%s/databases/%s\",\n          project, instance, database),\n      properties)) {\n    // Set AutoCommit=false to enable transactions.\n    connection.setAutoCommit(false);\n    connection.createStatement().execute(\"SET TRANSACTION READ ONLY\");\n\n    // First query: Retrieve customers and their orders\n    try (ResultSet resultSet = connection.createStatement().executeQuery(\n        \"SELECT c.CustomerId, c.CustomerName, o.OrderId, o.OrderDate \"\n            + \"FROM Customers c \"\n            + \"LEFT JOIN Orders o ON c.CustomerId = o.CustomerId \"\n            + \"ORDER BY c.CustomerId, o.OrderDate DESC\")) {\n      System.out.println(\"Customers and their Orders:\");\n      while (resultSet.next()) {\n        System.out.printf(\n            \"CustomerId: %d, CustomerName: %s, OrderId: %d, OrderDate: %s%n\",\n            resultSet.getLong(\"CustomerId\"),\n            resultSet.getString(\"CustomerName\"),\n            resultSet.getLong(\"OrderId\"),\n            resultSet.getDate(\"OrderDate\"));\n      }\n    }\n\n    // Second query: Retrieve order items for a specific order\n    try (ResultSet resultSet = connection.createStatement().executeQuery(\n        \"SELECT oi.OrderId, oi.ItemId, oi.Quantity, p.ProductName \"\n            + \"FROM OrderItems oi \"\n            + \"JOIN Products p ON oi.ItemId = p.ProductId \"\n            + \"WHERE oi.OrderId = (SELECT MAX(OrderId) FROM Orders) \"\n            + \"ORDER BY oi.ItemId\")) {\n      System.out.println(\"Order Items for the Most Recent Order:\");\n      while (resultSet.next()) {\n        System.out.printf(\n            \"OrderId: %d, ItemId: %d, Quantity: %d, ProductName: %s%n\",\n            resultSet.getLong(\"OrderId\"),\n            resultSet.getLong(\"ItemId\"),\n            resultSet.getInt(\"Quantity\"),\n            resultSet.getString(\"ProductName\"));\n      }\n    }\n    // End the read-only transaction by calling commit().\n    connection.commit();\n  }\n}",
      "mysql_schema": "CREATE TABLE Customers (\n    CustomerId INT PRIMARY KEY,\n    CustomerName VARCHAR(255)\n);\n\nCREATE TABLE Orders (\n    OrderId INT PRIMARY KEY,\n    CustomerId INT,\n    OrderDate DATE,\n    FOREIGN KEY (CustomerId) REFERENCES Customers(CustomerId)\n);\n\nCREATE TABLE Products (\n    ProductId INT PRIMARY KEY,\n    ProductName VARCHAR(255)\n);\n\nCREATE TABLE OrderItems (\n    OrderId INT,\n    ItemId INT,\n    Quantity INT,\n    PRIMARY KEY (OrderId, ItemId),\n    FOREIGN KEY (OrderId) REFERENCES Orders(OrderId),\n    FOREIGN KEY (ItemId) REFERENCES Products(ProductId)\n);",
      "spanner_schema": "CREATE TABLE Customers (\n    CustomerId INT64 NOT NULL,\n    CustomerName STRING(MAX),\n) PRIMARY KEY (CustomerId);\n\nCREATE TABLE Orders (\n    OrderId INT64 NOT NULL,\n    CustomerId INT64,\n    OrderDate DATE,\n) PRIMARY KEY (OrderId);\n\nCREATE TABLE Products (\n    ProductId INT64 NOT NULL,\n    ProductName STRING(MAX),\n) PRIMARY KEY (ProductId);\n\nCREATE TABLE OrderItems (\n    OrderId INT64 NOT NULL,\n    ItemId INT64 NOT NULL,\n    Quantity INT64,\n) PRIMARY KEY (OrderId, ItemId);",
      "ground_truth_solution": "static void readOnlyTransaction(final String project, final String instance, final String database, final Properties properties) throws SQLException {\n  try (Connection connection = DriverManager.getConnection(\n      String.format(\"jdbc:cloudspanner:/projects/%s/instances/%s/databases/%s\", project, instance, database), properties)) {\n    connection.setAutoCommit(false);\n    connection.createStatement().execute(\"SET TRANSACTION READ ONLY\");\n\n    // First query: Retrieve customers and their orders\n    try (ResultSet resultSet = connection.createStatement().executeQuery(\"SELECT c.CustomerId, c.CustomerName, o.OrderId, o.OrderDate FROM Customers c LEFT JOIN Orders o ON c.CustomerId = o.CustomerId ORDER BY c.CustomerId, o.OrderDate DESC\")) {\n      while (resultSet.next()) {\n        System.out.printf(\"CustomerId: %d, CustomerName: %s, OrderId: %d, OrderDate: %s%n\", resultSet.getLong(\"CustomerId\"), resultSet.getString(\"CustomerName\"), resultSet.getLong(\"OrderId\"), resultSet.getDate(\"OrderDate\"));\n      }\n    }\n\n    // Second query: Retrieve order items for the most recent order\n    try (ResultSet resultSet = connection.createStatement().executeQuery(\"SELECT oi.OrderId, oi.ItemId, oi.Quantity, p.ProductName FROM OrderItems oi JOIN Products p ON oi.ItemId = p.ProductId WHERE oi.OrderId = (SELECT MAX(OrderId) FROM Orders) ORDER BY oi.ItemId\")) {\n      while (resultSet.next()) {\n        System.out.printf(\"OrderId: %d, ItemId: %d, Quantity: %d, ProductName: %s%n\", resultSet.getLong(\"OrderId\"), resultSet.getLong(\"ItemId\"), resultSet.getInt(\"Quantity\"), resultSet.getString(\"ProductName\"));\n      }\n    }\n    connection.commit();\n  }\n}",
      "description": "This example demonstrates a read-only transaction in Spanner for retrieving customer and order information, including order items, with complex relationships between multiple tables."
    },

    {
      "functionality": "Bulk Read Data from Albums",
      "source_code": "static void readBulkData(\n    final String project,\n    final String instance,\n    final String database,\n    final Properties properties) throws SQLException {\n  try (Connection connection = DriverManager.getConnection(\n      String.format(\n          \"jdbc:cloudspanner:/projects/%s/instances/%s/databases/%s\",\n          project, instance, database),\n      properties)) {\n    // Run a query to fetch bulk data\n    String query = \"SELECT SingerId, AlbumId, AlbumTitle FROM Albums\";\n    try (PreparedStatement pstmt = connection.prepareStatement(query)) {\n      pstmt.setFetchSize(100); // Set fetch size for bulk read\n      try (ResultSet resultSet = pstmt.executeQuery()) {\n        while (resultSet.next()) {\n          // Process record\n          long singerId = resultSet.getLong(\"SingerId\");\n          long albumId = resultSet.getLong(\"AlbumId\");\n          String albumTitle = resultSet.getString(\"AlbumTitle\");\n          System.out.printf(\"SingerId: %d, AlbumId: %d, AlbumTitle: %s%n\",\n              singerId, albumId, albumTitle);\n        }\n      }\n    }\n  } catch (SQLException e) {\n    e.printStackTrace();\n    throw e; // Rethrow to propagate the exception\n  }\n}",
      "mysql_schema": "CREATE TABLE Albums (\n    SingerId INT,\n    AlbumId INT,\n    AlbumTitle VARCHAR(255),\n    PRIMARY KEY (SingerId, AlbumId)\n);",
      "spanner_schema": "CREATE TABLE Albums (\n    SingerId INT64,\n    AlbumId INT64,\n    AlbumTitle STRING(MAX)\n) PRIMARY KEY (SingerId, AlbumId);",
      "ground_truth_solution": "static void readBulkData(final String project, final String instance, final String database, final Properties properties) throws SQLException {\n  try (Connection connection = DriverManager.getConnection(\n      String.format(\"jdbc:cloudspanner:/projects/%s/instances/%s/databases/%s\", project, instance, database), properties)) {\n    String query = \"SELECT SingerId, AlbumId, AlbumTitle FROM Albums\";\n    try (PreparedStatement pstmt = connection.prepareStatement(query)) {\n      pstmt.setFetchSize(100); // Set fetch size for bulk read\n      try (ResultSet resultSet = pstmt.executeQuery()) {\n        while (resultSet.next()) {\n          long singerId = resultSet.getLong(\"SingerId\");\n          long albumId = resultSet.getLong(\"AlbumId\");\n          String albumTitle = resultSet.getString(\"AlbumTitle\");\n          System.out.printf(\"SingerId: %d, AlbumId: %d, AlbumTitle: %s%n\", singerId, albumId, albumTitle);\n        }\n      }\n    }\n  } catch (SQLException e) {\n    e.printStackTrace();\n    throw e;\n  }\n}",
      "description": "This example demonstrates bulk reading of album data using prepared statements in Spanner, similar to MySQL. The main changes include removing Spanner-specific features like Data Boost and maintaining consistent logic for data fetching and processing. Both implementations set a fetch size to optimize reading bulk data."
    },
    {
      "functionality": "Date/Time Data Type Conversion with JDBC",
      "source_code": "String sql = \"INSERT INTO events (name, event_date) VALUES (?, ?)\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setString(1, \"Workshop\");\nstmt.setDate(2, new java.sql.Date(System.currentTimeMillis()));\nstmt.executeUpdate();",
      "mysql_schema": "CREATE TABLE events (id INT PRIMARY KEY, name VARCHAR(255), event_date DATE);",
      "spanner_schema": "CREATE TABLE events (\n  id INT64 NOT NULL,\n  name STRING(MAX),\n  event_date DATE\n) PRIMARY KEY(id),",
      "ground_truth_solution": "String sql = \"INSERT INTO events (id, name, event_date) VALUES (?, ?, ?)\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nstmt.setLong(1, idGenerator.generateId()); // Or any other ID generation method\nstmt.setString(2, \"Workshop\");\nstmt.setDate(2, com.google.cloud.Date.fromJavaUtilDate(new java.util.Date())); // Use Spanner Date\nstmt.executeUpdate();",
      "description": "While both MySQL and Spanner support the DATE data type, use the Spanner JDBC driver's specific date handling for consistency. This involves converting a Java `java.util.Date` to a `com.google.cloud.Date` object before setting it in the PreparedStatement. Since Spanner doesn't have AUTO_INCREMENT, you'll need a separate ID generation strategy."
    },
    {
      "functionality": "ResultSet Metadata with JDBC",
      "source_code": "Statement stmt = conn.createStatement();\nResultSet rs = stmt.executeQuery(\"SELECT * FROM employees\");\nResultSetMetaData metaData = rs.getMetaData();\nint columnCount = metaData.getColumnCount();\nfor (int i = 1; i <= columnCount; i++) {\n  String columnName = metaData.getColumnName(i);\n  String columnType = metaData.getColumnTypeName(i);\n  // ... process column metadata\n}",
      "mysql_schema": "CREATE TABLE employees (id INT PRIMARY KEY, name VARCHAR(255), salary DECIMAL, hire_date DATE);",
      "spanner_schema": "CREATE TABLE employees (\n  id INT64 NOT NULL,\n  name STRING(MAX),\n  salary NUMERIC,\n  hire_date DATE\n) PRIMARY KEY(id);",
      "ground_truth_solution": "Statement stmt = conn.createStatement();\nResultSet rs = stmt.executeQuery(\"SELECT * FROM employees\");\nResultSetMetaData metaData = rs.getMetaData();\nint columnCount = metaData.getColumnCount();\nfor (int i = 1; i <= columnCount; i++) {\n  String columnName = metaData.getColumnName(i);\n  String columnType = metaData.getColumnTypeName(i);\n  // ... (no changes needed for metadata processing with JDBC)\n}",
      "description": "When using `ResultSetMetaData` with the Spanner JDBC driver, no specific adjustments are typically needed for metadata processing, as the driver handles the mapping of data types and column names."
    },
    {
      "functionality": "Batch Updates with JDBC",
      "source_code": "String sql = \"UPDATE accounts SET balance = balance + ? WHERE id = ?\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nconn.setAutoCommit(false); // Start a transaction\nfor (Account account : accountsToUpdate) {\n  stmt.setBigDecimal(1, account.getAmount());\n  stmt.setInt(2, account.getId());\n  stmt.addBatch();\n}\nstmt.executeBatch();\nconn.commit();",
      "mysql_schema": "CREATE TABLE accounts (id INT PRIMARY KEY, balance DECIMAL);",
      "spanner_schema": "CREATE TABLE accounts (\n  id INT64 NOT NULL,\n  balance NUMERIC\n) PRIMARY KEY(id);",
      "ground_truth_solution": "String sql = \"UPDATE accounts SET balance = balance + ? WHERE id = ?\";\nPreparedStatement stmt = conn.prepareStatement(sql);\nconn.setAutoCommit(false); // Start a transaction\nfor (Account account : accountsToUpdate) {\n  stmt.setBigDecimal(1, account.getAmount());\n  stmt.setLong(2, account.getId());\n  stmt.addBatch();\n}\nstmt.executeBatch();\nconn.commit();",
      "description": "The Spanner JDBC driver supports batch updates similar to MySQL. Ensure the tool correctly handles the transaction and the `executeBatch()` method."
    },
    {
      "functionality": "Transactions with JDBC",
      "source_code": "conn.setAutoCommit(false);\ntry {\n  // ... perform multiple DML statements\n  conn.commit();\n} catch (SQLException e) {\n  conn.rollback();\n}",
      "mysql_schema": "...",
      "spanner_schema": "...",
      "ground_truth_solution": "conn.setAutoCommit(false);\ntry {\n  // ... perform multiple DML statements (using PreparedStatement)\n  conn.commit();\n} catch (SQLException e) {\n  conn.rollback();\n}",
      "description": "The Spanner JDBC driver supports transactions similar to MySQL. The tool should correctly identify the transaction boundaries and use the standard JDBC methods (`setAutoCommit`, `commit`, `rollback`) for transaction management."
    },
    {
      "functionality": "JDBC Configuration Migration",
      "source_code": "static void configureJdbcConnection(final String instance, final String database) throws SQLException {\n  // MySQL JDBC Connection\n  String mysqlUrl = String.format(\"jdbc:mysql://%s/%s\", instance, database);\n  Properties mysqlProperties = new Properties();\n  mysqlProperties.setProperty(\"user\", \"username\");\n  mysqlProperties.setProperty(\"password\", \"password\");\n  mysqlProperties.setProperty(\"useSSL\", \"false\"); // MySQL SSL config\n\n  try (Connection mysqlConnection = DriverManager.getConnection(mysqlUrl, mysqlProperties)) {\n    System.out.println(\"MySQL connection successful.\");\n  }\n}",
      "ground_truth_solution": "static void configureJdbcConnection(final String project, final String instance, final String database) throws SQLException {\n  // Spanner JDBC Connection\n  String spannerUrl = String.format(\"jdbc:cloudspanner:/projects/%s/instances/%s/databases/%s\", project, instance, database);\n\n  try (Connection spannerConnection = DriverManager.getConnection(spannerUrl)) {\n    System.out.println(\"Spanner connection successful.\");\n  }\n}",
      "description": "This example illustrates the necessary configuration settings when migrating from MySQL JDBC to Spanner JDBC. The MySQL code includes properties for connection configuration, such as user credentials and SSL settings. In contrast, the Spanner code simplifies this by using a single connection URL, eliminating the need for additional properties."
    },
    {
      "functionality": "Maven Dependency Update",
      "source_code": "<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>8.0.28</version>\n</dependency>",
      "ground_truth_solution": "<dependency>\n    <groupId>com.google.cloud</groupId>\n    <artifactId>google-cloud-spanner-jdbc</artifactId>\n    <version>2.18.0</version>\n</dependency>",
      "description": "This example illustrates the necessary changes to the Maven dependency when migrating from MySQL to Spanner. The MySQL dependency specifies the MySQL Connector, while the Spanner dependency includes the Google Cloud Spanner JDBC library. This transition involves changing the group ID, artifact ID, and version to match the requirements of Google Cloud Spanner."
    }
  
  ]