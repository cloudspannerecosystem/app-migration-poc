[
  {
    "id": 100,
    "example": "How to migrate from `AUTO_INCREMENT` in MySQL to spanner?",
    "rewrite": "Cloud Spanner doesn’t support auto-incrementing columns like traditional relational databases. To handle this, you can use one of two methods: 1. Using UUIDs: Define a primary key as a STRING(36) column with GENERATE_UUID() as the default value: CREATE TABLE Singers ( SingerId STRING(36) DEFAULT (GENERATE_UUID()), Name STRING(MAX), Rank INT64 ) PRIMARY KEY (SingerId); 2. Using Sequences: Create a sequence with the bit_reversed_positive kind and use GET_NEXT_SEQUENCE_VALUE() for the primary key: CREATE SEQUENCE SingerIdSequence OPTIONS (sequence_kind='bit_reversed_positive'); CREATE TABLE Singers ( SingerId INT64 DEFAULT (GET_NEXT_SEQUENCE_VALUE(SEQUENCE SingerIdSequence)), Name STRING(MAX), Rank INT64 ) PRIMARY KEY (SingerId); Note: These snippets are DDL configurations, not DQL/DML. Do not use GENERATE_UUID() or GET_NEXT_SEQUENCE_VALUE() in your DQL or DML operations. Before migrating, check your schema to see if it already implements one of these methods. If not, you’ll need to adapt your application to generate unique keys before inserting records."
  },
  {
    "id": 200,
    "example": "In MySQL, `LAST_INSERT_ID()` returns the auto-increment value of the last inserted row. How can we achieve the same functionality in Spanner?",
    "rewrite": "While Spanner doesn't have a direct equivalent to MySQL's `LAST_INSERT_ID()` function, it offers a more efficient and versatile solution through its **DML Returning** feature. This allows you to retrieve data, including auto-generated keys, directly from your `INSERT` statement. \n\n```java\ntry (Connection connection = DriverManager.getConnection(\n        \"jdbc:cloudspanner:/projects/<project>/instances/<instance>/databases/<database>\",\n        \"<username>\",\n        \"<password>\")) {\n\n    Statement statement = connection.createStatement();\n    String sql = \"INSERT INTO MyTable (Col1, Col2) VALUES ('value1', 'value2') THEN RETURN MyTableId\"; \n\n    try (ResultSet resultSet = statement.executeQuery(sql)) { \n        if (resultSet.next()) {\n            long id = resultSet.getLong(\"MyTableId\"); // Get the generated ID\n            System.out.println(\"Generated ID: \" + id);\n        }\n    }\n} catch (SQLException e) {\n    System.err.println(\"Error: \" + e.getMessage());\n}\n```\n\nInstead of using a separate function call, you append `THEN RETURN` followed by the column name (e.g., `MyTableId`) to your `INSERT` statement. This instructs Spanner to return the value of that column from the newly inserted row. The returned value can then be accessed through the `ResultSet` object."
  },
  {
    "id": 300,
    "example": "Identify rows using a UUID",
    "rewrite": "Spanner fully supports automatic ID generation.  It does so using a sequenmce to automatically generate the ID.  Note that the sequence generates random (bit-reversed) integers, not sequential integers as in other database engines."
  },
  {
    "id": 400,
    "example": "Transactions and autocommit",
    "rewrite": "Spanner fully supports, and encourages the use of transactions.  Autocommit should be turned off except for code that is deliberately executing single-statement transactions."
  },
  {
    "id": 500,
    "example": "How can we efficiently handle large-scale deletes/updates in Spanner with performance optimization?",
    "rewrite": "To efficiently handle large-scale deletes and updates in Google Cloud Spanner, use Partitioned DML for high throughput and low latency. This method should be applied to bulk updates only and not for pointed updates where a WHERE clause involves specific variables or IDs with an equality condition. Ensure your operations meet the following conditions: they must be single table operations, idempotent (not dependent on existing row values), and avoid nested queries. Here’s an example code snippet:\n\n```\ntry (Connection connection = DriverManager.getConnection(connectionString)) {\n    // Enable Partitioned DML\n    connection.createStatement().execute(\"SET AUTOCOMMIT_DML_MODE='PARTITIONED_NON_ATOMIC'\");\n\n    // Example Partitioned DML Update\n    String sql = \"UPDATE Users SET status = 'inactive' WHERE last_login < TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 1 YEAR)\";\n    try (PreparedStatement statement = connection.prepareStatement(sql)) {\n        int affectedRows = statement.executeUpdate();\n        System.out.println(\"Updated rows: \" + affectedRows);\n    }\n} catch (SQLException e) {\n    e.printStackTrace();\n}\n```\n"
  },
  {
    "id": 600,
    "example": "DML",
    "rewrite": "Code should generally continue to use DML.  Performance-sensitive transactions that don't read any data, such as transactions that only INSERT data, can consider using Mutations for improved latency; but this is an optional secondary change."
  },
  {
    "id": 700,
    "example": "INSERT",
    "rewrite": "Code should generally continue to use DML.  Performance-sensitive transactions that don't read any data, such as transactions that only INSERT data, can consider using Mutations for improved latency; but this is an optional secondary change."
  },
  {
    "id": 800,
    "example": "Adding timestamps to records",
    "rewrite": "If it's necessary to add the current timestamp (NOW()) to a record, the timestamp should be added using Spanner's COMMIT_TIMESTAMP mechanism.  If the affected timestamp column doesn't support commit timestamps, this should be noted in a code comment, and other alternative examples should also be provided, such as using the CURRENT_TIMESTAMP() SQL function."
  },
  {
    "id": 900,
    "example": "DML parameters",
    "rewrite": "When generating JDBC, use JDBC's parameters syntax, specifically using question marks as placeholders for parameters:  INSERT INTO t (a, b) VALUES (?, ?)"
  },
  {
    "id": 1000,
    "example": "SELECT parameters",
    "rewrite": "When generating JDBC, use JDBC's parameters syntax, specifically using question marks as placeholders for parameters:  SELECT data FROM table WHERE pk = ?"
  }
]
