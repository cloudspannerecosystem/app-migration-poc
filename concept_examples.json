[
  {
    "id": 100,
    "example": "How to migrate from `AUTO_INCREMENT` in MySQL to spanner?",
    "rewrite": "Cloud Spanner offers two schema-level configurations for generating primary keys, eliminating the need for application-side logic:\n\n**Option 1: UUIDs**\n\nTo automatically generate UUIDs, define the column as: \n\n```example\nCOLUMN_NAME STRING(LENGTH) DEFAULT (GENERATE_UUID())\n```\n\n**Option 2: Bit-reversed Sequences**\n\nUse the bit-reversed sequence for key generation in an INT64 column. \n\n```example\nCREATE SEQUENCE SingerIdSequence OPTIONS (sequence_kind=\"bit_reversed_positive\");\nCREATE TABLE Singers (\n    SingerId INT64 DEFAULT (GET_NEXT_SEQUENCE_VALUE(SEQUENCE SingerIdSequence)),\n    Name STRING(MAX),\n    Rank INT64\n) PRIMARY KEY (SingerId);\n```\n\nThese approaches improve performance and scalability by evenly distributing write operations. If any of the DDL is not configured in the new spanner schema, modify the applicaiton code to use the client side generation of id."
  },
  {
    "id": 200,
    "example": "In MySQL, `LAST_INSERT_ID()` returns the auto-increment value of the last inserted row. How can we achieve the same functionality in Spanner?",
    "rewrite": "While Spanner doesn't have a direct equivalent to MySQL's `LAST_INSERT_ID()` function, it offers a more efficient and versatile solution through its **DML Returning** feature. This allows you to retrieve data, including auto-generated keys, directly from your `INSERT` statement. \n\n```java\ntry (Connection connection = DriverManager.getConnection(\n        \"jdbc:cloudspanner:/projects/<project>/instances/<instance>/databases/<database>\",\n        \"<username>\",\n        \"<password>\")) {\n\n    Statement statement = connection.createStatement();\n    String sql = \"INSERT INTO MyTable (Col1, Col2) VALUES ('value1', 'value2') THEN RETURN MyTableId\"; \n\n    try (ResultSet resultSet = statement.executeQuery(sql)) { \n        if (resultSet.next()) {\n            long id = resultSet.getLong(\"MyTableId\"); // Get the generated ID\n            System.out.println(\"Generated ID: \" + id);\n        }\n    }\n} catch (SQLException e) {\n    System.err.println(\"Error: \" + e.getMessage());\n}\n```\n\nInstead of using a separate function call, you append `THEN RETURN` followed by the column name (e.g., `MyTableId`) to your `INSERT` statement. This instructs Spanner to return the value of that column from the newly inserted row. The returned value can then be accessed through the `ResultSet` object."
  },
  {
    "id": 300,
    "example": "Identify rows using a UUID",
    "rewrite": "Spanner fully supports automatic ID generation.  It does so using a sequenmce to automatically generate the ID.  Note that the sequence generates random (bit-reversed) integers, not sequential integers as in other database engines."
  },
  {
    "id": 400,
    "example": "Transactions and autocommit",
    "rewrite": "Spanner fully supports, and encourages the use of transactions.  Autocommit should be turned off except for code that is deliberately executing single-statement transactions."
  },
  {
    "id": 500,
    "example": "How can we efficiently handle large-scale deletes/updates in Spanner with performance optimization?",
    "rewrite": "To efficiently handle large-scale deletes and updates in Google Cloud Spanner, use Partitioned DML for high throughput and low latency, ensuring it meets conditions: single table operations, idempotence (no dependence on existing row values), and no nested queries. Example code:\n\n```\ntry (Connection connection = DriverManager.getConnection(connectionString)) {\n    // Enable Partitioned DML\n    connection.createStatement().execute(\"SET AUTOCOMMIT_DML_MODE='PARTITIONED_NON_ATOMIC'\");\n\n    // Example Partitioned DML Update\n    String sql = \"UPDATE Users SET status = 'inactive' WHERE last_login < TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 1 YEAR)\";\n    try (PreparedStatement statement = connection.prepareStatement(sql)) {\n        int affectedRows = statement.executeUpdate();\n        System.out.println(\"Updated rows: \" + affectedRows);\n    }\n} catch (SQLException e) {\n    e.printStackTrace();\n}\n```\n"
  }
]
